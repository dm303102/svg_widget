<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Preview Widget</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .controls label { flex: 1 1 120px; white-space: nowrap; }
    canvas { cursor: default; }
  </style>
</head>
<body>
  <h1>Upload &amp; Preview Your SVGs</h1>

  <div class="controls">
    <label>Canvas Width (in): <input type="number" id="widthInput" step="any" placeholder="3.5" /></label>
    <label>Canvas Height (in): <input type="number" id="heightInput" step="any" placeholder="2" /></label>
    <button id="renderBtn">Render Canvas</button>
    <button id="toggleOrientation">Switch to Landscape</button>
    <button id="exportBtn">Export Canvas</button>
    <button id="exportSvgBtn">Export as SVG</button>
  </div>

  <div id="fileInputContainer" style="display:none; margin-top:1em;">
    <input type="file" id="fileInput" accept=".svg" multiple />
  </div>

  <ul id="svgList"></ul>
  <canvas id="mainCanvas"></canvas>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const images = [];
      let selectedId = null;
      let dragging = false;
      let dragOffset = { x: 0, y: 0 };
      const DPI = 96;
      const borderPx = 4;
      const handleSize = 12;

      const widthInput = document.getElementById('widthInput');
      const heightInput = document.getElementById('heightInput');
      const renderBtn = document.getElementById('renderBtn');
      const toggleOrient = document.getElementById('toggleOrientation');
      const exportBtn = document.getElementById('exportBtn');
      const exportSvgBtn = document.getElementById('exportSvgBtn');
      const fileInputContainer = document.getElementById('fileInputContainer');
      const fileInput = document.getElementById('fileInput');
      const svgList = document.getElementById('svgList');
      const canvas = document.getElementById('mainCanvas');
      const ctx = canvas.getContext('2d');

      function redrawAll() {
        const wIn = parseFloat(widthInput.value);
        const hIn = parseFloat(heightInput.value);
        if (!(wIn > 0 && hIn > 0)) {
          fileInputContainer.style.display = 'none';
          return;
        }
        fileInputContainer.style.display = 'block';
        const wPx = Math.round(wIn * DPI);
        const hPx = Math.round(hIn * DPI);
        canvas.width = wPx + borderPx * 2;
        canvas.height = hPx + borderPx * 2;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.lineWidth = borderPx; ctx.strokeStyle = '#000';
        ctx.strokeRect(borderPx/2, borderPx/2, wPx + borderPx, hPx + borderPx);

        ctx.fillStyle = '#000'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(`${wIn}\"`, borderPx + wPx/2, canvas.height - 4);
        ctx.save(); ctx.translate(canvas.width - 4, borderPx + hPx/2); ctx.rotate(Math.PI/2);
        ctx.fillText(`${hIn}\"`, 0, 0); ctx.restore();

        images.forEach(item => {
          const drawW = item.origW * item.fitScale * item.scalePercent;
          const drawH = item.origH * item.fitScale * item.scalePercent;
          ctx.drawImage(item.image, item.x, item.y, drawW, drawH);
          if (item.id === selectedId) {
            ctx.lineWidth = 2; ctx.strokeStyle = 'red';
            ctx.strokeRect(item.x, item.y, drawW, drawH);
            // move handle only at top-left
            ctx.fillStyle = '#fff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
            ctx.fillRect(item.x - handleSize/2, item.y - handleSize/2, handleSize, handleSize);
            ctx.strokeRect(item.x - handleSize/2, item.y - handleSize/2, handleSize, handleSize);
          }
        });
      }

      function updateList() {
        svgList.innerHTML = '';
        images.forEach((item, index) => {
          const li = document.createElement('li');
          li.dataset.id = item.id;
          if (item.id === selectedId) li.classList.add('selected');
          li.innerHTML = `SVG ${index + 1} <button class="moveBtn" data-id="${item.id}">Move</button> <button class="scaleBtn" data-id="${item.id}">Scale</button> <button class="deleteBtn" data-id="${item.id}">Delete</button>`;
          svgList.appendChild(li);
        });
      }

      function selectImage(id) {
        selectedId = id;
        updateList();
        redrawAll();
      }

      svgList.addEventListener('click', e => {
        const id = e.target.dataset.id;
        if (e.target.matches('.deleteBtn')) {
          images.splice(images.findIndex(i => i.id === id), 1);
          selectedId = images[0]?.id || null;
          updateList(); redrawAll(); return;
        }
        if (e.target.matches('.scaleBtn')) {
          const item = images.find(i => i.id === id);
          const val = prompt('Enter scale percent', Math.round(item.scalePercent * 100));
          if (val !== null) { item.scalePercent = parseFloat(val) / 100; redrawAll(); }
          return;
        }
        if (e.target.matches('.moveBtn')) {
          selectImage(id); return;
        }
        const li = e.target.closest('li'); if (li) selectImage(li.dataset.id);
      });

      renderBtn.addEventListener('click', redrawAll);

      toggleOrient.addEventListener('click', () => {
        [widthInput.value, heightInput.value] = [heightInput.value, widthInput.value];
        toggleOrient.textContent = toggleOrient.textContent.includes('Landscape') ? 'Switch to Portrait' : 'Switch to Landscape';
        const wIn = parseFloat(widthInput.value);
        const hIn = parseFloat(heightInput.value);
        const wPx = Math.round(wIn * DPI);
        const hPx = Math.round(hIn * DPI);
        images.forEach(item => {
          item.fitScale = Math.min(wPx / item.origW, hPx / item.origH);
          const drawW = item.origW * item.fitScale * item.scalePercent;
          const drawH = item.origH * item.fitScale * item.scalePercent;
          item.x = borderPx + (wPx - drawW) / 2;
          item.y = borderPx + (hPx - drawH) / 2;
        });
        redrawAll();
      });

      // drag logic only via move handle
      canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const item = images.find(i => i.id === selectedId);
        if (item) {
          const hx = item.x - handleSize/2;
          const hy = item.y - handleSize/2;
          if (x >= hx && x <= hx + handleSize && y >= hy && y <= hy + handleSize) {
            dragging = true;
            dragOffset = { x: x - item.x, y: y - item.y };
          }
        }
      });
      canvas.addEventListener('mousemove', e => {
        if (dragging) {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const item = images.find(i => i.id === selectedId);
          if (item) {
            item.x = x - dragOffset.x;
            item.y = y - dragOffset.y;
            redrawAll();
          }
        }
      });
      ['mouseup', 'mouseleave'].forEach(ev => canvas.addEventListener(ev, () => { dragging = false; }));

      fileInput.addEventListener('change', e => {
        const files = Array.from(e.target.files);
        const wIn = parseFloat(widthInput.value);
        const hIn = parseFloat(heightInput.value);
        if (!(wIn > 0 && hIn > 0)) return;
        const wPx = Math.round(wIn * DPI);
        const hPx = Math.round(hIn * DPI);
        files.forEach(file => {
          const reader = new FileReader();
          reader.onload = evt => {
            const svgText = evt.target.result;
            const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.documentElement;
            let origW = parseFloat(svgEl.getAttribute('width')) || parseFloat(svgEl.getAttribute('viewBox').split(' ')[2]);
            let origH = parseFloat(svgEl.getAttribute('height')) || parseFloat(svgEl.getAttribute('viewBox').split(' ')[3]);
            const fitScale = Math.min(wPx / origW, hPx / origH);
            const id = Date.now() + '_' + Math.random();
            const blob = new Blob([svgText], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const img = new Image();
            img.onload = () => {
              URL.revokeObjectURL(url);
              const drawW = origW * fitScale;
              const drawH = origH * fitScale;
              const x = borderPx + (wPx - drawW) / 2;
              const y = borderPx + (hPx - drawH) / 2;
              images.push({ id, svgText, image: img, origW, origH, fitScale, scalePercent: 1, x, y });
              selectImage(id);
              updateList();
              redrawAll();
            };
            img.src = url;
          };
          reader.readAsText(file);
        });
      });
    });
  </script>
</body>
</html>
