<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Preview Widget</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .controls label { flex: 1 1 120px; white-space: nowrap; }
    canvas { cursor: move; }
  </style>
</head>
<body>
  <h1>Upload &amp; Preview Your SVGs</h1>

  <div class="controls">
    <label>Canvas Width (in): <input type="number" id="widthInput" step="any" placeholder="3.5" /></label>
    <label>Canvas Height (in): <input type="number" id="heightInput" step="any" placeholder="2" /></label>
    <button id="renderBtn">Render Canvas</button>
    <label>Scale: <input type="range" id="scaleSlider" min="10" max="200" value="100" /><span id="scaleValue">100%</span></label>
    <button id="toggleOrientation">Switch to Landscape</button>
    <button id="exportBtn">Export Canvas</button>
    <button id="exportSvgBtn">Export as SVG</button>
  </div>

  <!-- File input shown only after dimensions set -->
  <div id="fileInputContainer" style="display:none; margin-top:1em;">
    <input type="file" id="fileInput" accept=".svg" multiple />
  </div>

  <ul id="svgList"></ul>
  <canvas id="mainCanvas"></canvas>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const images = [];
      let selectedId = null;
      let dragging = false;
      let dragOffset = { x: 0, y: 0 };
      const DPI = 96;
      const borderPx = 4;

      // DOM refs
      const widthInput = document.getElementById('widthInput');
      const heightInput = document.getElementById('heightInput');
      const renderBtn = document.getElementById('renderBtn');
      const scaleSlider = document.getElementById('scaleSlider');
      const scaleValue = document.getElementById('scaleValue');
      const toggleOrient = document.getElementById('toggleOrientation');
      const exportBtn = document.getElementById('exportBtn');
      const exportSvgBtn = document.getElementById('exportSvgBtn');
      const fileInputContainer = document.getElementById('fileInputContainer');
      const fileInput = document.getElementById('fileInput');
      const svgList = document.getElementById('svgList');
      const canvas = document.getElementById('mainCanvas');
      const ctx = canvas.getContext('2d');

      function redrawAll() {
        const wIn = parseFloat(widthInput.value);
        const hIn = parseFloat(heightInput.value);
        if (!(wIn > 0 && hIn > 0)) {
          fileInputContainer.style.display = 'none';
          return;
        }
        fileInputContainer.style.display = 'block';
        const wPx = Math.round(wIn * DPI);
        const hPx = Math.round(hIn * DPI);
        canvas.width = wPx + borderPx * 2;
        canvas.height = hPx + borderPx * 2;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.lineWidth = borderPx; ctx.strokeStyle = '#000';
        ctx.strokeRect(borderPx/2, borderPx/2, wPx + borderPx, hPx + borderPx);

        // inch labels
        ctx.fillStyle = '#000'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(`${wIn}\"`, borderPx + wPx/2, canvas.height - 4);
        ctx.save(); ctx.translate(canvas.width - 4, borderPx + hPx/2); ctx.rotate(Math.PI/2);
        ctx.fillText(`${hIn}\"`, 0, 0); ctx.restore();

        // draw images and handle
        images.forEach(item => {
          const drawW = item.origW * item.fitScale * item.scalePercent;
          const drawH = item.origH * item.fitScale * item.scalePercent;
          ctx.drawImage(item.image, item.x, item.y, drawW, drawH);
          if (item.id === selectedId) {
            ctx.lineWidth = 2; ctx.strokeStyle = 'red';
            ctx.strokeRect(item.x, item.y, drawW, drawH);
            // draw handles
            const size = 8;
            [[0,0],[drawW,0],[0,drawH],[drawW,drawH]].forEach(([dx,dy]) => {
              ctx.fillStyle = 'white'; ctx.strokeStyle = 'black';
              ctx.lineWidth = 1;
              ctx.fillRect(item.x+dx-size/2, item.y+dy-size/2, size, size);
              ctx.strokeRect(item.x+dx-size/2, item.y+dy-size/2, size, size);
            });
          }
        });
      }

      function updateList() {
        svgList.innerHTML = '';
        images.forEach((item, index) => {
          const li = document.createElement('li');
          li.dataset.id = item.id;
          if (item.id === selectedId) li.classList.add('selected');
          li.innerHTML = `SVG ${index+1} <button class="deleteBtn" data-id="${item.id}">Delete</button>`;
          svgList.appendChild(li);
        });
      }

      function selectImage(id) {
        selectedId = id; updateList();
        const item = images.find(i => i.id===id);
        if (item) {
          scaleSlider.value = Math.round(item.scalePercent*100);
          scaleValue.textContent = `${scaleSlider.value}%`;
        }
      }

      // Events
      svgList.addEventListener('click', e => {
        if (e.target.matches('.deleteBtn')) {
          const id = e.target.dataset.id;
          images.splice(images.findIndex(i=>i.id===id),1);
          selectedId = images[0]?.id||null;
          updateList(); redrawAll(); return;
        }
        const li = e.target.closest('li'); if (li) selectImage(li.dataset.id);
      });

      scaleSlider.addEventListener('input', ()=>{
        const item = images.find(i=>i.id===selectedId);
        if(item){ item.scalePercent = scaleSlider.value/100; redrawAll(); }
        scaleValue.textContent = `${scaleSlider.value}%`;
      });

      renderBtn.addEventListener('click', redrawAll);

      toggleOrient.addEventListener('click', ()=>{
        [widthInput.value, heightInput.value] = [heightInput.value, widthInput.value];
        toggleOrient.textContent = toggleOrient.textContent.includes('Landscape') ? 'Switch to Portrait' : 'Switch to Landscape';
        // update fitScale & recenter
        const wIn=parseFloat(widthInput.value), hIn=parseFloat(heightInput.value);
        const wPx=Math.round(wIn*DPI), hPx=Math.round(hIn*DPI);
        images.forEach(item=>{
          item.fitScale = Math.min(wPx/item.origW, hPx/item.origH);
          const drawW=item.origW*item.fitScale*item.scalePercent;
          const drawH=item.origH*item.fitScale*item.scalePercent;
          item.x=borderPx+(wPx-drawW)/2; item.y=borderPx+(hPx-drawH)/2;
        }); redrawAll();
      });

      exportBtn.addEventListener('click', ()=>{
        const link=document.createElement('a');
        link.href=canvas.toDataURL('image/png');
        link.download='canvas-export.png'; link.click();
      });

      exportSvgBtn.addEventListener('click', ()=>{
        const wIn=parseFloat(widthInput.value), hIn=parseFloat(heightInput.value);
        const wPx=Math.round(wIn*DPI), hPx=Math.round(hIn*DPI);
        const xmlns='http://www.w3.org/2000/svg';
        let svg=`<?xml version="1.0" encoding="UTF-8"?><svg xmlns="${xmlns}" width="${wPx+borderPx*2}" height="${hPx+borderPx*2}" viewBox="0 0 ${wPx+borderPx*2} ${hPx+borderPx*2}">`;
        svg+=`<rect x="${borderPx/2}" y="${borderPx/2}" width="${wPx+borderPx}" height="${hPx+borderPx}" fill="none" stroke="black" stroke-width="${borderPx}"/>`;
        svg+=`<text x="${borderPx+wPx/2}" y="${hPx+borderPx*2-4}" font-family="sans-serif" font-size="16" text-anchor="middle">${wIn}\"</text>`;
        svg+=`<text transform="translate(${wPx+borderPx*2-4},${borderPx+hPx/2}) rotate(90)" font-family="sans-serif" font-size="16" text-anchor="middle">${hIn}\"</text>`;
        images.forEach(item=>{
          const drawW=item.origW*item.fitScale*item.scalePercent;
          const drawH=item.origH*item.fitScale*item.scalePercent;
          const inner=new DOMParser().parseFromString(item.svgText,'image/svg+xml').documentElement.innerHTML;
          svg+=`<svg x="${item.x}" y="${item.y}" width="${drawW}" height="${drawH}" viewBox="0 0 ${item.origW} ${item.origH}" xmlns="${xmlns}">${inner}</svg>`;
        });
        svg+='</svg>';
        const blob=new Blob([svg],{type:'image/svg+xml'});
        const url=URL.createObjectURL(blob);
        const link=document.createElement('a'); link.href=url; link.download='canvas-export.svg'; link.click(); URL.revokeObjectURL(url);
      });

      // Drag logic and pick topmost
      canvas.addEventListener('mousedown', e=>{
        const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left; const y=e.clientY-rect.top;
        for(let i=images.length-1;i>=0;i--){ const item=images[i];
          const drawW=item.origW*item.fitScale*item.scalePercent;
          const drawH=item.origH*item.fitScale*item.scalePercent;
          if(x>=item.x&&x<=item.x+drawW&&y>=item.y&&y<=item.y+drawH){ selectImage(item.id); dragging=true; dragOffset={x:x-item.x,y:y-item.y}; break; }
        }
      });
      canvas.addEventListener('mousemove', e=>{ if(dragging){ const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left; const y=e.clientY-rect.top; const item=images.find(i=>i.id===selectedId); if(item){ item.x=x-dragOffset.x; item.y=y-dragOffset.y; redrawAll(); }} });
      ['mouseup','mouseleave'].forEach(ev=>canvas.addEventListener(ev,()=>dragging=false));

      // Load SVGs
      fileInput.addEventListener('change', e=>{
        const files=Array.from(e.target.files);
        const wIn=parseFloat(widthInput.value), hIn=parseFloat(heightInput.value);
        if(!(wIn>0&&hIn>0)) return;
        const wPx=Math.round(wIn*DPI), hPx=Math.round(hIn*DPI);
        files.forEach(file=>{
          const reader=new FileReader(); reader.onload=evt=>{
            const svgText=evt.target.result;
            const doc=new DOMParser().parseFromString(svgText,'image/svg+xml');
            const svgEl=doc.documentElement;
            let origW=parseFloat(svgEl.getAttribute('width'))||parseFloat(svgEl.getAttribute('viewBox').split(' ')[2]);
            let origH=parseFloat(svgEl.getAttribute('height'))||parseFloat(svgEl.getAttribute('viewBox').split(' ')[3]);
            const fitScale=Math.min(wPx/origW,hPx/origH);
            const id=Date.now()+'_'+Math.random();
            const blob=new Blob([svgText],{type:'image/svg+xml'}); const url=URL.createObjectURL(blob);
            const img=new Image(); img.onload=()=>{ URL.revokeObjectURL(url); const scalePercent=1; const drawW=origW*fitScale*scalePercent; const drawH=origH*fitScale*scalePercent; const x=borderPx+(wPx-drawW)/2; const y=borderPx+(hPx-drawH)/2; images.push({id,svgText,image:img,origW,origH,fitScale,scalePercent,x,y}); selectImage(id); updateList(); redrawAll(); };
            img.src=url;
          }; reader.readAsText(file);
        });
      });
    });
  </script>
</body>
</html>
